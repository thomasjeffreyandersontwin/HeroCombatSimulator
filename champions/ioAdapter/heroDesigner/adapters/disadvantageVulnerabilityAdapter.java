/*
 * powerEnergyBlast.java
 *
 * Created on March 29, 2004, 10:11 PM
 */

package champions.ioAdapter.heroDesigner.adapters;

import champions.Ability;
import champions.parameters.ParameterList;
import champions.SpecialEffect;
import champions.ioAdapter.heroDesigner.AbstractPowerXMLAdapter;
import champions.ioAdapter.heroDesigner.PowerXMLAdapter;
import org.w3c.dom.Node;
import champions.*;
import champions.interfaces.*;
import champions.powers.SpecialParameterENDSource;
import champions.powers.SpecialParameterMultipowerSlot;
import champions.powers.powerENDReserve;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import xml.DefaultXMLHandler;
import xml.XMLHandler;
import xml.XMLParser;
import xml.XMLParserException;


/**
 *
 * @author  1425
 */
public class disadvantageVulnerabilityAdapter extends AbstractPowerXMLAdapter implements PowerXMLAdapter {
    
    private static String XMLID = "VULNERABILITY";
    private static String[][] translationArray = {
        { "INPUT", "Input", "inputIsSpecial", },
        { "ADDER(XMLID=ATTACK).OPTION", "AttackIs", "attackIsSpecial", },
        { "MODIFIER(XMLID=MULTIPLIER).OPTION", "Multiplier", "multiplierSpecial" },
    };
    
    /** Returns the XMLID for this Power.
     *
     * Subclass should either override this to return their XMLID or override
     * the identify method to do more complicated identification tasks.
     */
    public String getXMLID() {
        return XMLID;
    }
    
    /** Returns the Translation Array for the Power.
     *
     * The Subclass should either override this to return their translationArray
     *or override the importXML method to do more complicated import tasks.
     */
    public String[][] getTranslationArray() {
        return translationArray;
    }
    
public void attackIsSpecial(Ability ability, Node node, String attrValue, ParameterList pl, String parameterName, String specialData) {
        if ( "UNCOMMON".equals(attrValue) ) {
            pl.setParameterValue(parameterName, "Uncommon");
        }
        else if ( "COMMON".equals(attrValue) ) {
            pl.setParameterValue(parameterName, "Common");
        }
        else if ( "VERYCOMMON".equals(attrValue) ) {
            pl.setParameterValue(parameterName, "Very Common");
        }
    }
    
    public void multiplierSpecial(Ability ability, Node node, String attrValue, ParameterList pl, String parameterName, String specialData) {
        if (attrValue.endsWith("STUN")) {
            pl.setParameterValue("ApplyTo", "STUN");
        }
        else if (attrValue.endsWith("BODY")) {
            pl.setParameterValue("ApplyTo", "BODY");
        }
        else if (attrValue.endsWith("EFFECT")) {
            pl.setParameterValue("ApplyTo", "Effect");
        }
        
        if (attrValue.startsWith("HALF")) {
            pl.setParameterValue(parameterName, "x1\u00BD");
        }
        else if (attrValue.startsWith("TWICE")) {
            pl.setParameterValue(parameterName, "x2");
        }        
    }
    public void inputIsSpecial(Ability ability, Node node, String attrValue, ParameterList pl, String parameterName, String specialData) {
        // Check for Special FX tags
        Node sfxNode = node.getAttributes().getNamedItem("INPUT");
        if ( sfxNode != null ) {
            String sfxName = sfxNode.getNodeValue();
            if ( sfxName.equals("Default")== false) {
                SpecialEffect se = PADRoster.getNewSpecialEffectInstance( sfxName );
                if ( se != null ) {
                    ability.addSpecialEffect( se );
                }
            }
        }      
    }
}
