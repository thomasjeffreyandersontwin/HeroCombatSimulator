/*
 * AbilityEditor.java
 *
 * Created on July 7, 2001, 11:18 AM
 */

package champions;

import champions.abilityTree.AbilityNode;
import champions.abilityTree.AbilityTreeNode;
import champions.abilityTree.AbilityTreeTable;
import champions.abilityTree.AbilityTreeTableModel;
import javax.swing.JPanel;
import javax.swing.tree.TreePath;
import tjava.Destroyable;
import treeTable.TreeTableColumn;
import treeTable.TreeTableColumnModel;
import champions.interfaces.ChampionsConstants;

/**
 *
 * @author  twalker
 * @version 
 */
public class AbilityEditor extends JPanel implements Destroyable {
    
    protected boolean useRealCost;
    

    /** Creates new form AbilityEditor */
    public AbilityEditor() {
        initComponents ();
        abilityTree.setScrollPane(abilityScroll);
        
        AbilityTreeTableModel atm = new AbilityTreeTableModel( new AbilityTreeNode() );
        abilityTree.setTreeTableModel(atm);
        //abilityTree.setRootVisible(true);
        
        setUseRealCost(true);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the FormEditor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        abilityScroll = new javax.swing.JScrollPane();
        abilityTree = new champions.abilityTree.AbilityTreeTable();

        setLayout(new java.awt.BorderLayout());

        abilityTree.setAutoResizeMode(2);
        abilityTree.setOpaque(false);
        abilityScroll.setViewportView(abilityTree);

        add(abilityScroll, java.awt.BorderLayout.CENTER);

    }// </editor-fold>//GEN-END:initComponents

    /** Getter for property ability.
     * @return Value of property ability.
 */
    public Ability getAbility() {
        return ability;
    }    

    /** Setter for property ability.
     * @param ability New value of property ability.
 */
    public void setAbility(Ability ability) {
        if ( this.ability != ability ) {
            this.ability = ability;
            AbilityTreeNode atn = new AbilityTreeNode();
            
            AbilityNode an = new AbilityNode(null, null, null, ability);
            an.setDeleteEnabled(false);
            an.setActivateEnabled(false);
            an.setTree(abilityTree);
            
            atn.add(an);
            
            AbilityTreeTableModel atm = new AbilityTreeTableModel(atn);
 
            an.setModel(atm);
            abilityTree.setTreeTableModel(atm);
            
            TreePath tp = new TreePath(an.getPath());
            
            abilityTree.setSelectionPath(tp);
            abilityTree.expandPath(tp);
            
        }
    }
    
    /** Getter for property abilityTree.
     * @return Value of property abilityTree.
     *
     */
    public AbilityTreeTable getAbilityTree() {
        return abilityTree;
    }
    
    public void destroy() {
        // Free all of our resources, if necessary...
        abilityScroll.setViewportView( null );
        abilityTree.destroy();
        abilityTree = null;
        abilityScroll = null;
    }
    
    /**
     * Getter for property useRealCost.
     * @return Value of property useRealCost.
     */
    public boolean isUseRealCost() {
        return useRealCost;
    }
    
    /**
     * Setter for property useRealCost.
     * @param useRealCost New value of property useRealCost.
     */
    public void setUseRealCost(boolean useRealCost) {
        this.useRealCost = useRealCost;
        
//        if ( abilityTree.getTreeTableHeader() != null ) {
//            TreeTableColumnModel cm = abilityTree.getTreeTableHeader().getColumnModel();
//            if ( useRealCost ) {
//                try {
//                    int index = cm.getColumnIndex( "Real" );
//                }
//                catch ( IllegalArgumentException iae ) {
//                    cm.addColumn( new TreeTableColumn( ChampionsConstants.ABILITY_TREE_REALCOLUMN));
//                }
//                
//                try {
//                    int index = cm.getColumnIndex( "Cost" );
//                    cm.removeColumn( cm.getColumn(index) );
//                }
//                catch ( IllegalArgumentException iae ) {
//                }
//                
//            }
//            else {
//                try {
//                    int index = cm.getColumnIndex( "Cost" );
//                }
//                catch ( IllegalArgumentException iae ) {
//                    cm.addColumn( new TreeTableColumn( ChampionsConstants.ABILITY_TREE_PTSCOLUMN));
//                }
//                
//                try {
//                    int index = cm.getColumnIndex( "Real" );
//                    cm.removeColumn( cm.getColumn(index) );
//                }
//                catch ( IllegalArgumentException iae ) {
//                }
//            }
//        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane abilityScroll;
    private champions.abilityTree.AbilityTreeTable abilityTree;
    // End of variables declaration//GEN-END:variables

    /** Holds value of property ability. */
    private Ability ability;    

}
