/*
 * KnockbackEffectPanel.java
 *
 * Created on November 27, 2001, 12:22 AM
 */

package champions.attackTree;

import champions.*;
import champions.enums.KnockbackEffect;
import champions.event.PADValueEvent;
import champions.interfaces.AbilityIterator;
import champions.interfaces.ChampionsConstants;
import champions.interfaces.PADValueListener;
import javax.swing.ButtonGroup;
import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;

/**
 *
 * @author  twalker
 */
public class ThrowDamageRollPanel extends JPanel implements PADValueListener, AttackTreeInputPanel, ChampionsConstants {
    
    static private KnockbackEffectPanel defaultPanel = null;
    
    private AttackTreePanel atip = null;
    
    private String rollMode;
    
    
    /** Holds value of property battleEvent. */
    private BattleEvent battleEvent;
    
    /** Stores the EventListenerList */
    private EventListenerList listenerList;
    
    /** Holds value of property dice. */
    private Dice dice;
    
    /** Holds value of property diceName. */
    private String diceName;
    
    /** Holds value of property targetReferenceNumber. */
    private int targetReferenceNumber;
    
    /** Holds value of property target. */
    private Target target;
    
    /** Holds value of property targetGroup. */
    private String targetGroup;
    
    /** Holds value of property knockbackGroup. */
    private String knockbackGroup;
   
    /** Holds value of property effect. */
    private KnockbackEffect effect;
    
    /** Holds value of property distance. */
    private int distance;
    
    /** Creates new form KnockbackEffectPanel */
    public ThrowDamageRollPanel() {
        initComponents();
        
        ButtonGroup bg = new ButtonGroup();
//        bg.add(collisionButton);
//        bg.add(noCollisionButton);
//        bg.add(noEffectButton);
//        TargetskillModifier.setDescription("Modifier");
//        TargetskillModifier.setPropertyName("Attack.TARGETMODIFIER");
//        TargetskillModifier.addPADValueListener( this );
        
        knockbackDamagePanel.setDescription("Knockback Damage");
    }
    
    static public KnockbackEffectPanel getDefaultPanel(BattleEvent be, Target target, String knockbackGroup, String targetGroup) {
        if ( defaultPanel == null ) defaultPanel = new KnockbackEffectPanel();
        
        defaultPanel.setBattleEvent(be);
        defaultPanel.setTarget(target);
        defaultPanel.setKnockbackGroup(knockbackGroup);
      //  defaultPanel.setDiceName(diceName);
        defaultPanel.setTargetGroup(targetGroup);
        
        return defaultPanel;
    }
    
    public void setupPanel() {
        if ( getBattleEvent() != null  ) {
            int dindex = battleEvent.getDiceIndex(diceName, targetGroup);
            boolean auto = battleEvent.getDiceAutoRoll(dindex);
            Dice d = battleEvent.getDiceRoll(dindex);
            setDice(d);
            setRollMode( auto ? AUTO_ROLL : MANUAL_ROLL );
        }
        ActivationInfo ai = battleEvent.getActivationInfo();
        Integer modifier = ai.getIntegerValue( "Attack.TARGETMODIFIER" );
        updateSkillRoll();
        if (isBreakfallEnabled(target)) {
//            TargetrollField.setEnabled(true);
//            TargetrollCheckbox.setEnabled(true);
//            TargetskillModifier.setEnabled(true);
//            jLabel1.setEnabled(true);
//            TargetneededLabel.setEnabled(true);
        }
        else {
//            TargetrollField.setEnabled(false);
//            TargetrollCheckbox.setEnabled(false);
//            TargetskillModifier.setEnabled(false);
//            jLabel1.setEnabled(false);
//            TargetneededLabel.setEnabled(false);
        }        
    }
    
    private void setupDescription() {
        
//        if ( distance > 0 ) {
//            descriptionLabel.setText( getTarget().getName() + " was knocked back " );
//            distanceLabel.setText( Integer.toString(distance));
//            descriptionLabel2.setText( "\".");
//        }
//        else {
//            descriptionLabel.setText( getTarget().getName() + " was not knocked back." );
//            distanceLabel.setText("");
//            descriptionLabel2.setText( "");
//        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        damageRollGroup = new javax.swing.JPanel();
        knockbackDamagePanel = new champions.PADDiceValueEditor();
        fillerGroup = new javax.swing.JPanel();

        setLayout(new java.awt.GridBagLayout());

        damageRollGroup.setLayout(new java.awt.GridBagLayout());

        damageRollGroup.setBorder(new javax.swing.border.TitledBorder("Throw Damage Roll"));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        damageRollGroup.add(knockbackDamagePanel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        add(damageRollGroup, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.gridheight = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(fillerGroup, gridBagConstraints);

    }//GEN-END:initComponents
                            /** Getter for property battleEvent.
     * @return Value of property battleEvent.
     */
    public BattleEvent getBattleEvent() {
        return battleEvent;
    }
    
    /** Setter for property battleEvent.
     * @param battleEvent New value of property battleEvent.
     */
    public void setBattleEvent(BattleEvent battleEvent) {
        this.battleEvent = battleEvent;
    }
    
    /** Getter for property dice.
     * @return Value of property dice.
     */
    public Dice getDice() {
        return dice;
    }
    
    /** Setter for property dice.
     * @param dice New value of property dice.
     */
    public void setDice(Dice dice) {
        this.dice = dice;
    }
    
    
    public void showPanel(AttackTreePanel atip) {
        
        // Grab the target's current effect
        BattleEvent be = getBattleEvent();
        ActivationInfo ai = battleEvent.getActivationInfo();
        int tindex = ai.getTargetIndex(targetReferenceNumber, getTargetGroup());
        
        int kbindex = be.getKnockbackIndex(getTarget(), getKnockbackGroup());
        
        int distance = getBattleEvent().getKnockbackDistance(kbindex);
        
        setDistance(distance);
        
        KnockbackEffect effect;
        
        if ( distance <= 0 ) {
            effect = KnockbackEffect.NOEFFECT;
        }
        else {
            effect = be.getKnockbackEffect(kbindex);
        }
        setEffect( (effect==null) ? KnockbackEffect.NOCOLLISION : effect);
        
        Dice diceRoll = be.getKnockbackDamageRoll(kbindex);
        boolean auto = be.getKnockbackAutorollDamage(kbindex);
        
        knockbackDamagePanel.setAutoroll(auto);
        if ( diceRoll != null ) knockbackDamagePanel.setDice(diceRoll);
        this.atip = atip;
        setupPanel();
    }
    
    public JPanel getPanel() {
        return this;
    }
    
    public void hidePanel() {
        // When the panel is hidden, make sure you copy the values out
        if ( getBattleEvent() != null) {
            int dindex = battleEvent.getDiceIndex(diceName, targetGroup );
            String rollmode = getRollMode();
            
            if ( rollmode.equals(AUTO_ROLL) ) {
                if ( getDice() == null ) {
                    Dice autoRoll = new Dice(3);
                    battleEvent.setDiceRoll(dindex, autoRoll);
                }
                else {
                    battleEvent.setDiceRoll(dindex, getDice());
                }
                battleEvent.setDiceAutoRoll(dindex, true);
            }
            else if ( rollmode.equals(MANUAL_ROLL) ) {
               // String roll = TargetrollField.getText();
//                Dice diceRoll = null;
//                try {
//                    int value = Integer.parseInt(roll);
//                    
//                    diceRoll = new Dice(value, 0);
//                }
//                catch(NumberFormatException nfe) {
//                    // Don't do anything
//                }
//                battleEvent.setDiceRoll(dindex, diceRoll);
//                battleEvent.setDiceAutoRoll(dindex, false );
            }
        }
        
        
        BattleEvent be = getBattleEvent();
        int kbindex = be.getKnockbackIndex(getTarget(), getKnockbackGroup());
        be.setKnockbackEffect(kbindex, getEffect() );
        
        Dice kbdiceRoll = knockbackDamagePanel.getDice();
        boolean auto = knockbackDamagePanel.isAutoroll();
        
        be.setKnockbackDamageRoll(kbindex, kbdiceRoll);
        be.setKnockbackAutorollDamage(kbindex, auto);
        ActivationInfo ai = battleEvent.getActivationInfo();
        Integer modifier = ai.getIntegerValue( "Attack.TARGETMODIFIER" );
        if ( modifier == null ) modifier = new Integer(0);
      //  TargetskillModifier.setValue(modifier);
    }
    
    
    
    /** Getter for property target.
     * @return Value of property target.
     */
    public Target getTarget() {
        return target;
    }
    
    /** Setter for property target.
     * @param target New value of property target.
     */
    public void setTarget(Target target) {
        this.target = target;
        updateSkillRoll();
    }
    
    /** Getter for property knockbackGroup.
     * @return Value of property knockbackGroup.
     */
    public String getKnockbackGroup() {
        return knockbackGroup;
    }
    
    /** Setter for property knockbackGroup.
     * @param knockbackGroup New value of property knockbackGroup.
     */
    public void setKnockbackGroup(String knockbackGroup) {
        this.knockbackGroup = knockbackGroup;
    }
    
    /** Getter for property effect.
     * @return Value of property effect.
     */
    public KnockbackEffect getEffect() {
        return effect;
    }
    
    /** Setter for property effect.
     * @param effect New value of property effect.
     */
    public final void setEffect(KnockbackEffect effect) {
//        if ( effect != null ) {
//            this.effect = effect;
//            ActivationInfo ai = battleEvent.getActivationInfo();
//            int tindex = ai.getTargetIndex(targetReferenceNumber, getTargetGroup());
//            
//            
//            if ( this.effect.equals(KnockbackEffect.COLLISION)  ) {
//                if (collisionButton.isSelected() == false) collisionButton.setSelected(true);
//                int kbindex = getBattleEvent().getKnockbackIndex(getTarget(), getKnockbackGroup());
//                int damageDice = getBattleEvent().getKnockbackAmount(kbindex);
//                
//                knockbackDamagePanel.setDiceSize(damageDice);
//                knockbackDamagePanel.setEnabled(true);
//                TargetrollField.setEnabled(false);
//                TargetrollCheckbox.setEnabled(false);
//                TargetskillModifier.setEnabled(false);
//                jLabel1.setEnabled(false);
//                TargetneededLabel.setEnabled(false);
//                
//                
//            }
//            else if ( this.effect.equals("NOCOLLISION")) {
//                if ( noCollisionButton.isSelected() == false ) noCollisionButton.setSelected(true);
//                int kbindex = getBattleEvent().getKnockbackIndex(getTarget(), getKnockbackGroup());
//                int damageDice = getBattleEvent().getKnockbackAmount(kbindex);
//                knockbackDamagePanel.setDiceSize(damageDice/2);
//                knockbackDamagePanel.setEnabled(true);
//                if (isBreakfallEnabled(target)) {
//                    TargetrollField.setEnabled(true);
//                    TargetrollCheckbox.setEnabled(true);
//                    TargetskillModifier.setEnabled(true);
//                    jLabel1.setEnabled(true);
//                    TargetneededLabel.setEnabled(true);
//                }
//            }
//            else if ( this.effect.equals(Knockback.NOEFFECT)  ) {
//                if ( noEffectButton.isSelected() == false ) noEffectButton.setSelected(true);
//                //knockbackDamagePanel.setEnabled(false);
//                //if (
//                TargetrollField.setEnabled(false);
//                TargetrollCheckbox.setEnabled(false);
//                TargetskillModifier.setEnabled(false);
//                jLabel1.setEnabled(false);
//                TargetneededLabel.setEnabled(false);
//                
//            }
//        }
    }
    
    public String getAutoBypassOption() {
        return "SHOW_KNOCKBACK_EFFECT_PANEL";
    }
    
    public Target getAutoBypassTarget() {
        return getTarget();
    }
    
    /** Getter for property distance.
     * @return Value of property distance.
     */
    public int getDistance() {
        return distance;
    }
    
    public void setTargetReferenceNumber(int targetReferenceNumber) {
        this.targetReferenceNumber = targetReferenceNumber;
    }
    
    /** Getter for property targetGroup.
     * @return Value of property targetGroup.
     */
    public String getTargetGroup() {
        return targetGroup;
    }
    
    /** Setter for property distance.
     * @param distance New value of property distance.
     */
    public void setDistance(int distance) {
        this.distance = distance;
        
//        if ( distance <= 0 ) {
//            noCollisionButton.setEnabled(false);
//            collisionButton.setEnabled(false);
//        }
//        else {
//            noCollisionButton.setEnabled(true);
//            collisionButton.setEnabled(true);
//        }
        
        setupDescription();
    }
    
    /** Getter for property rollMode.
     * @return Value of property rollMode.
     */
    public String getRollMode() {
        return rollMode;
    }
    
    
    /** Setter for property rollMode.
     * @param rollMode New value of property rollMode.
     */
    public void setRollMode(String rollMode) {
        String oldMode = this.rollMode;
        this.rollMode = rollMode;
//        if ( rollMode.equals(MANUAL_ROLL) ) {
//            TargetrollCheckbox.setSelected(false);
//            
//            if ( getDice() != null && getDice().isRealized() ) {
//                TargetrollField.setText( getDice().getStun().toString() );
//            }
//            else {
//                TargetrollField.setText( "" );
//            }
//            
//            TargetrollField.requestFocus();
//        }
//        else if ( rollMode.equals(AUTO_ROLL) ) {
//            TargetrollCheckbox.setSelected(true);
//            
//            TargetrollField.setText("AUTO");
//        }
        
        
    }
    /** Getter for property diceName.
     * @return Value of property diceName.
     */
    public String getDiceName() {
        return this.diceName;
    }
    
    /** Setter for property diceName.
     * @param diceName New value of property diceName.
     */
    public void setDiceName(String diceName) {
        this.diceName = diceName;
    }
    
    protected void fireChangeEvent() {
        if ( listenerList != null ) {
            ChangeEvent e = new ChangeEvent(this);
            // Guaranteed to return a non-null array
            Object[] listeners = listenerList.getListenerList();
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length-2; i>=0; i-=2) {
                if (listeners[i]==ChangeListener.class) {
                    // System.out.println( "Firing chance event to: " + listeners[i+1].toString());
                    ((ChangeListener)listeners[i+1]).stateChanged(e);
                }
            }
        }
    }
    
    public boolean PADValueChanging(PADValueEvent evt) {
        if ( battleEvent != null ) {
//            if ( evt.getSource() == TargetskillModifier ) {
//                Ability ability = battleEvent.getAbility();
//                int value = ((Integer)evt.getValue()).intValue();
//                
//            }
            
        }
        return true;
    }
    
    public void PADValueChanged(PADValueEvent evt) {
        ActivationInfo ai = battleEvent.getActivationInfo();
        ai.add( evt.getKey(), evt.getValue(),true );
        fireChangeEvent();
        updateSkillRoll();
        
        
    }
    
    
    /** Setter for property targetGroup.
     * @param targetGroup New value of property targetGroup.
     *
     */
    public void setTargetGroup(String targetGroup) {
        this.targetGroup = targetGroup;
        updateSkillRoll();
    }
    
    
    /*
     
     
     *  Adds a <code>Battle</code> listener.
     *
     *  @param l  the <code>ChangeListener</code> to add
     */
    public void addChangeListener(ChangeListener l) {
        listenerList.add(ChangeListener.class,l);
    }
    
    /**
     * Removes a <code>Battle</code> listener.
     *
     * @param l  the <code>BattleListener</code> to remove
     * //==
     * public void removeChangeListener(ChangeListener l) {
     * listenerList.remove(ChangeListener.class,l);
     * }
     *
     */
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel damageRollGroup;
    private javax.swing.JPanel fillerGroup;
    private champions.PADDiceValueEditor knockbackDamagePanel;
    // End of variables declaration//GEN-END:variables

    
    private void updateSkillRoll() {
        Integer targetmodifier = battleEvent.getActivationInfo().getIntegerValue( "Attack.TARGETMODIFIER" );
        Integer targetbaseroll = battleEvent.getActivationInfo().getIntegerValue( "Attack.TARGETBASEROLL" );
        if ( targetmodifier == null ) targetmodifier = new Integer(0);
        if ( targetbaseroll == null ) targetbaseroll = new Integer(0);
  //      TargetskillModifier.setValue(targetmodifier);
    //    TargetneededLabel.setText( Integer.toString(targetmodifier.intValue() + targetbaseroll.intValue() - distance/2 ) );
    }
    
    public boolean isBreakfallEnabled(Target target) {
        
        Ability Breakfall = PADRoster.getSharedAbilityInstance("Breakfall");
        
        ActivationInfo ai = battleEvent.getActivationInfo();
        //Target source = Battle.currentBattle.getActiveTarget();
        
        AbilityIterator aiter = target.getSkills();
        
        
        while (aiter.hasNext() ) { // Check to see if there is another item
            // Rip next ability from the iterator.
            // This a is guaranteed to have a power which is actually a skill
            // since we used the getSkills.  If we use getAbilities() we will
            // actually get both skills and powers.
            Ability a = aiter.nextAbility();
            if ( a.equals(Breakfall)&& a.isEnabled(target, false) ) {
                return true;
            }
            
            
        }
        return false;
    }
    
}
