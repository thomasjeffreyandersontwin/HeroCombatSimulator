/*
 * ToHitPanel.java
 *
 * Created on November 11, 2001, 9:09 PM
 */

package champions.attackTree;

import champions.*;
import champions.event.PADValueEvent;
import champions.interfaces.ChampionsConstants;
import champions.interfaces.PADValueListener;
import javax.swing.ButtonGroup;
import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;

/**
 *
 * @author  twalker
 */
public class SkillRollPanel extends JPanel implements PADValueListener, AttackTreeInputPanel, ChampionsConstants {
    
    /** Stores the static, default toHit panel. */
    static private SkillRollPanel defaultPanel = null;
    
    private AttackTreePanel atip = null;
    
    private String rollMode;
    
    
    /** Holds value of property battleEvent. */
    private BattleEvent battleEvent;
    
    /** Stores the EventListenerList */
    private EventListenerList listenerList;
    
    /** Holds value of property dice. */
    private Dice dice;
    
    
    private int effectRoll;
    
    /** Holds value of property diceName. */
    private String diceName;
    
    /** Creates new form ToHitPanel */
    public SkillRollPanel() {
        initComponents();
        
        ButtonGroup bg = new ButtonGroup();
        // Setup Spread paramters
        skillModifier.setDescription("Modifier");
        skillModifier.setPropertyName("Attack.MODIFIER");
        skillModifier.addPADValueListener( this );
        SvSRoll.setDescription("Skill Vs. Skill Roll");
        //activeCheckSvS.setPropertyName("Attack.MODIFIER");
        SvSRoll.setPropertyName("Attack.SvS");
        SvSRoll.addPADValueListener( this );
        
    }
    
    static public SkillRollPanel getDefaultPanel(BattleEvent be, Ability skill, Target target, String diceName, String targetGroup, int effectRoll) {
        if ( defaultPanel == null ) defaultPanel = new SkillRollPanel();
        
        defaultPanel.setBattleEvent(be);
        defaultPanel.setSkill(skill);
        defaultPanel.setTarget(target);
        defaultPanel.setDiceName(diceName);
        defaultPanel.setTargetGroup(targetGroup);
        defaultPanel.setEffectRoll(effectRoll);
        return defaultPanel;
        
    }
    
    public void setupPanel() {
        if ( getBattleEvent() != null  ) {
            //added for dependence activation
            updateSkillRoll();
            int dindex = battleEvent.getDiceIndex(diceName, targetGroup);
            boolean auto = battleEvent.getDiceAutoRoll(dindex);
            Dice d = battleEvent.getDiceRoll(dindex);
            
            ActivationInfo ai = battleEvent.getActivationInfo();
            
            setDice(d);
            setRollMode( auto ? AUTO_ROLL : MANUAL_ROLL );
            Integer modifier = ai.getIntegerValue( "Attack.MODIFIER" );
            if ( modifier == null ) modifier = new Integer(0);
            skillModifier.setValue(modifier);
            
            if (ai.getAbility().isDisadvantage()) {
                SvSRoll.setVisible( false );
            }
            else {
                SvSRoll.setVisible( true );
            }
            
            boolean svsroll = ai.getBooleanValue("Attack.SvS");
            SvSRoll.setValue( svsroll ? "TRUE" : "FALSE" );
            
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        rollGroup = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        neededLabel = new javax.swing.JLabel();
        rollSubGroup = new javax.swing.JPanel();
        rollField = new javax.swing.JTextField();
        rollCheckbox = new javax.swing.JCheckBox();
        skillModifier = new champions.PADIntegerEditor();
        SvSRoll = new champions.PADBooleanEditor();
        fillerGroup = new javax.swing.JPanel();

        setLayout(new java.awt.GridBagLayout());

        rollGroup.setLayout(new java.awt.GridBagLayout());

        rollGroup.setBorder(new javax.swing.border.TitledBorder("Skill Roll"));
        jLabel1.setText("Skill Roll Needed: ");
        rollGroup.add(jLabel1, new java.awt.GridBagConstraints());

        neededLabel.setFont(new java.awt.Font("Dialog", 0, (int) (24 * GlobalFontSettings.SizeMagnification)));;
        neededLabel.setForeground(java.awt.Color.blue);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        rollGroup.add(neededLabel, gridBagConstraints);

        rollSubGroup.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        rollField.setText("AUTO");
        rollField.setMinimumSize(new java.awt.Dimension(40, 20));
        rollField.setPreferredSize(new java.awt.Dimension(40, 20));
        rollField.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                rollFieldFocusGained(evt);
            }
        });

        rollSubGroup.add(rollField);

        rollCheckbox.setText("AutoRoll Activation");
        rollCheckbox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rollCheckboxActionPerformed(evt);
            }
        });

        rollSubGroup.add(rollCheckbox);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        rollGroup.add(rollSubGroup, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.ipadx = 4;
        gridBagConstraints.ipady = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        rollGroup.add(skillModifier, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        rollGroup.add(SvSRoll, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        add(rollGroup, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(fillerGroup, gridBagConstraints);

    }//GEN-END:initComponents
    
    private void rollCheckboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rollCheckboxActionPerformed
        // Add your handling code here:
        if ( rollCheckbox.isSelected() ) {
            setRollMode(AUTO_ROLL);
            setDice(null);
        }
        else {
            setRollMode(MANUAL_ROLL);
        }
    }//GEN-LAST:event_rollCheckboxActionPerformed
    
    private void rollFieldFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_rollFieldFocusGained
        // Add your handling code here:
        
        if ( getRollMode().equals(MANUAL_ROLL) == false ) {
            setRollMode(MANUAL_ROLL);
        }
        
        rollField.selectAll();
    }//GEN-LAST:event_rollFieldFocusGained
    
    /** Getter for property battleEvent.
     * @return Value of property battleEvent.
     */
    public BattleEvent getBattleEvent() {
        return battleEvent;
    }
    
    /** Setter for property battleEvent.
     * @param battleEvent New value of property battleEvent.
     */
    public void setBattleEvent(BattleEvent battleEvent) {
        this.battleEvent = battleEvent;
    }
    
    /** Getter for property dice.
     * @return Value of property dice.
     */
    public Dice getDice() {
        return dice;
    }
    
    /** Setter for property dice.
     * @param dice New value of property dice.
     */
    public void setDice(Dice dice) {
        this.dice = dice;
    }
    
    public void showPanel(AttackTreePanel atip) {
        this.atip = atip;
        setupPanel();
    }
    
    public JPanel getPanel() {
        return this;
    }
    
    public void hidePanel() {
        // When the panel is hidden, make sure you copy the values out
        if ( getBattleEvent() != null) {
            int dindex = battleEvent.getDiceIndex(diceName, targetGroup);
            
            String rollmode = getRollMode();
            
            if ( rollmode.equals(AUTO_ROLL) ) {
                if ( getDice() == null ) {
                    Dice autoRoll = new Dice(3);
                    battleEvent.setDiceRoll(dindex, autoRoll);
                }
                else {
                    battleEvent.setDiceRoll(dindex, getDice());
                }
                battleEvent.setDiceAutoRoll(dindex, true);
            }
            else if ( rollmode.equals(MANUAL_ROLL) ) {
                String roll = rollField.getText();
                Dice diceRoll = null;
                try {
                    int value = Integer.parseInt(roll);
                    
                    diceRoll = new Dice(value, 0);
                }
                catch(NumberFormatException nfe) {
                    // Don't do anything
                }
                
                battleEvent.setDiceRoll(dindex, diceRoll);
                battleEvent.setDiceAutoRoll(dindex, false );
            }
        }
    }
    
    /** Getter for property rollMode.
     * @return Value of property rollMode.
     */
    public String getRollMode() {
        return rollMode;
    }
    
    
    /** Setter for property rollMode.
     * @param rollMode New value of property rollMode.
     */
    public void setRollMode(String rollMode) {
        String oldMode = this.rollMode;
        this.rollMode = rollMode;
        if ( rollMode.equals(MANUAL_ROLL) ) {
            rollCheckbox.setSelected(false);
            
            if ( getDice() != null && getDice().isRealized() ) {
                rollField.setText( getDice().getStun().toString() );
            }
            else {
                rollField.setText( "" );
            }
            
            rollField.requestFocus();
        }
        else if ( rollMode.equals(AUTO_ROLL) ) {
            rollCheckbox.setSelected(true);
            
            rollField.setText("AUTO");
        }
        
        
    }
    
    /** Getter for property diceName.
     * @return Value of property diceName.
     */
    public String getDiceName() {
        return this.diceName;
    }
    
    /** Setter for property diceName.
     * @param diceName New value of property diceName.
     */
    public void setDiceName(String diceName) {
        this.diceName = diceName;
    }
    
    protected void fireChangeEvent() {
        if ( listenerList != null ) {
            ChangeEvent e = new ChangeEvent(this);
            // Guaranteed to return a non-null array
            Object[] listeners = listenerList.getListenerList();
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length-2; i>=0; i-=2) {
                if (listeners[i]==ChangeListener.class) {
                    // System.out.println( "Firing chance event to: " + listeners[i+1].toString());
                    ((ChangeListener)listeners[i+1]).stateChanged(e);
                }
            }
        }
    }
    
    public boolean PADValueChanging(PADValueEvent evt) {
        if ( battleEvent != null ) {
            if ( evt.getSource() == skillModifier ) {
                Ability ability = battleEvent.getAbility();
                int value = ((Integer)evt.getValue()).intValue();
                
            }
            
        }
        return true;
    }
    
    public void PADValueChanged(PADValueEvent evt) {
        ActivationInfo ai = battleEvent.getActivationInfo();
        ai.add( evt.getKey(), evt.getValue(),true );
        fireChangeEvent();
        
        updateSkillRoll();
    }
    
    private void updateSkillRoll() {
        Ability ability = battleEvent.getAbility();
        ActivationInfo ai = battleEvent.getActivationInfo();
        Target source = battleEvent.getSource();
        Integer usedsl = new Integer(0);
        Ability effectAbility;
        Integer level = new Integer(0);
        Integer allocatesl = new Integer(0);
        Integer skillbonus = new Integer(0);
        int count, i;
        
        int sbtot = 0;
        //Effect effectsl = source.getEffect("Skill Levels");
        
        if ( ai.isActivated() == false ) {
            //          battleEvent.addAIStateEvent(ai, ai.getState(), "ACTIVATED" );
            //            ai.setState("ACTIVATED");
            //            //ability.add("Ability.ACTIVATED", "TRUE",  true);
            //            //be.addActivateEvent( ability, true );
            //
            // Run through the source Effects to let them know that Ability is activating
            // First build list, then run through list (just in case it changes).
            count = source.getEffectCount();
            Effect[] sourceEffects = new Effect[count];
            for (i=0;i<count;i++) {
                sourceEffects[i] = source.getEffect(i);
            }
            
            for (i=0;i<count;i++) {
                if ( source.hasEffect(sourceEffects[i]) ) {
                    sourceEffects[i].skillIsActivating(battleEvent,ability);
                    skillbonus = sourceEffects[i].getIntegerValue("Effect.SKILLLEVEL");
                    usedsl = (Integer)sourceEffects[i].getValue("Effect.USEDSL");
                    effectAbility = (Ability)sourceEffects[i].getValue("Effect.ABILITY");
                    if (effectAbility != null) {
                        level = effectAbility.getIntegerValue("Power.SKILLLEVEL");
                        allocatesl = effectAbility.getIntegerValue("CombatLevel.ALLOCATESL");
                    }
                    if (level == null) level = new Integer(0);
                    if (usedsl == null) usedsl = new Integer(0);
                    if (skillbonus != null) {
                        if (level.intValue() >= (usedsl.intValue() + skillbonus.intValue())) {
                            sbtot = sbtot + skillbonus.intValue();
                            usedsl = new Integer(usedsl.intValue() + skillbonus.intValue());
                        }
                        else {
                            sbtot = sbtot + (level.intValue() - usedsl.intValue());
                            usedsl = new Integer(level.intValue());
                        }
                    }
                }
            }
        }
        
        //below is a quick hack to force the effectroll for dependence to take the place
        //of the skillroll.  WHen skillrolls are revamped this should be taken into
        //account in the design
        int skillroll = skill.getSkillRoll(target);
        if (skillroll < 0) {
            skillroll = getEffectRoll();
        }
        if (skillroll < 3) {
            skillroll = 3;
        }
        
        neededLabel.setText( Integer.toString( sbtot + skillroll + skillModifier.getValue().intValue()) );
    }
/*
 
 
 *  Adds a <code>Battle</code> listener.
 *
 *  @param l  the <code>ChangeListener</code> to add
 */
    public void addChangeListener(ChangeListener l) {
        listenerList.add(ChangeListener.class,l);
    }
    
    /** Getter for property target.
     * @return Value of property target.
     *
     */
    public Target getTarget() {
        return this.target;
    }
    
    /** Setter for property target.
     * @param target New value of property target.
     *
     */
    public void setTarget(Target target) {
        this.target = target;
        updateSkillRoll();
    }
    
    /** Getter for property skill.
     * @return Value of property skill.
     *
     */
    public Ability getSkill() {
        return this.skill;
    }
    
    /** Setter for property skill.
     * @param skill New value of property skill.
     *
     */
    public void setSkill(Ability skill) {
        this.skill = skill;
        updateSkillRoll();
    }
    
    /** Getter for property targetGroup.
     * @return Value of property targetGroup.
     *
     */
    public String getTargetGroup() {
        return this.targetGroup;
    }
    
    /** Setter for property targetGroup.
     * @param targetGroup New value of property targetGroup.
     *
     */
    public void setTargetGroup(String targetGroup) {
        this.targetGroup = targetGroup;
    }
    
    /**
     * Removes a <code>Battle</code> listener.
     *
     * @param l  the <code>BattleListener</code> to remove
     * //==
     * public void removeChangeListener(ChangeListener l) {
     * listenerList.remove(ChangeListener.class,l);
     * }
     *
     */
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private champions.PADBooleanEditor SvSRoll;
    private javax.swing.JPanel fillerGroup;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel neededLabel;
    private javax.swing.JCheckBox rollCheckbox;
    private javax.swing.JTextField rollField;
    private javax.swing.JPanel rollGroup;
    private javax.swing.JPanel rollSubGroup;
    private champions.PADIntegerEditor skillModifier;
    // End of variables declaration//GEN-END:variables
    
    /** Holds value of property target. */
    private Target target;
    
    /** Holds value of property skill. */
    private Ability skill;
    
    /** Holds value of property targetGroup. */
    private String targetGroup;
    
    /** Getter for property targetReferenceNumber.
     * @return Value of property targetReferenceNumber.
     */
    public int getEffectRoll() {
        return effectRoll;
    }
    
    /** Setter for property targetReferenceNumber.
     * @param targetReferenceNumber New value of property targetReferenceNumber.
     */
    public void setEffectRoll(int effectroll) {
        this.effectRoll = effectroll;
    }
    
}
