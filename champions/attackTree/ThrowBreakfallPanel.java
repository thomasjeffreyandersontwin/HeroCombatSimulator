/*
 * KnockbackEffectPanel.java
 *
 * Created on November 27, 2001, 12:22 AM
 */

package champions.attackTree;

import champions.*;
import champions.event.PADValueEvent;
import champions.interfaces.AbilityIterator;
import champions.interfaces.ChampionsConstants;
import champions.interfaces.PADValueListener;
import javax.swing.ButtonGroup;
import javax.swing.JPanel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;

/**
 *
 * @author  twalker
 */
public class ThrowBreakfallPanel extends JPanel implements PADValueListener, AttackTreeInputPanel, ChampionsConstants {
    
    static private ThrowBreakfallPanel defaultPanel = null;
    
    private AttackTreePanel atip = null;
    
    private String rollMode;
    
    /** Holds value of property battleEvent. */
    private BattleEvent battleEvent;
    
    /** Stores the EventListenerList */
    private EventListenerList listenerList;
    
    /** Holds value of property dice. */
    private Dice dice;
    
    /** Holds value of property diceName. */
    private String diceName;
    
    protected String targetGroup;
    
    /** Creates new form KnockbackEffectPanel */
    public ThrowBreakfallPanel() {
        initComponents();
        

        TargetskillModifier.setDescription("Modifier");
        TargetskillModifier.setPropertyName("ActivationInfo.THROWBREAKFALLMODIFIER");
        TargetskillModifier.addPADValueListener( this );
        
    }
    
    static public ThrowBreakfallPanel getDefaultPanel(BattleEvent be, String diceName, String targetGroup) {
        if ( defaultPanel == null ) defaultPanel = new ThrowBreakfallPanel();
        
        defaultPanel.setBattleEvent(be);
        defaultPanel.setDiceName(diceName);
        defaultPanel.setTargetGroup(targetGroup);
        
        return defaultPanel;
    }
    
    public void setupPanel() {
        if ( getBattleEvent() != null  ) {
            ActivationInfo ai = battleEvent.getActivationInfo();
            double dc = ai.getDoubleValue("ActivationInfo.THROWDC").doubleValue();

            setDC(dc); 
            
            int dindex = battleEvent.getDiceIndex(diceName, getTargetGroup());
            boolean auto = battleEvent.getDiceAutoRoll(dindex);
            Dice d = battleEvent.getDiceRoll(dindex);
            setDice(d);
            setRollMode( auto ? AUTO_ROLL : MANUAL_ROLL );
        }
       // ActivationInfo ai = battleEvent.getActivationInfo();
       // Integer modifier = ai.getIntegerValue( "ActivationInfo.THROWBREAKFALLMODIFIER" );
        updateSkillRoll();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        breakfallGroup = new javax.swing.JPanel();
        TargetskillModifier = new champions.PADIntegerEditor();
        jLabel1 = new javax.swing.JLabel();
        TargetneededLabel = new javax.swing.JLabel();
        TargetrollField = new javax.swing.JTextField();
        TargetrollCheckbox = new javax.swing.JCheckBox();
        fillerGroup = new javax.swing.JPanel();

        setLayout(new java.awt.GridBagLayout());

        breakfallGroup.setLayout(new java.awt.GridBagLayout());

        breakfallGroup.setBorder(new javax.swing.border.TitledBorder("Breakfall Roll"));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        breakfallGroup.add(TargetskillModifier, gridBagConstraints);

        jLabel1.setText("Skill Roll Needed: ");
        breakfallGroup.add(jLabel1, new java.awt.GridBagConstraints());

        TargetneededLabel.setFont(new java.awt.Font("Dialog", 0, (int) (24 * GlobalFontSettings.SizeMagnification)));;
        TargetneededLabel.setForeground(java.awt.Color.blue);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        breakfallGroup.add(TargetneededLabel, gridBagConstraints);

        TargetrollField.setText("AUTO");
        TargetrollField.setMinimumSize(new java.awt.Dimension(40, 20));
        TargetrollField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TargetrollFieldActionPerformed(evt);
            }
        });
        TargetrollField.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                TargetrollFieldFocusGained(evt);
            }
        });

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        breakfallGroup.add(TargetrollField, gridBagConstraints);

        TargetrollCheckbox.setText("AutoRoll Activation");
        TargetrollCheckbox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TargetrollCheckboxActionPerformed(evt);
            }
        });

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        breakfallGroup.add(TargetrollCheckbox, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(breakfallGroup, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.gridheight = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(fillerGroup, gridBagConstraints);

    }//GEN-END:initComponents

    private void TargetrollFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TargetrollFieldActionPerformed
        // Add your handling code here:
    }//GEN-LAST:event_TargetrollFieldActionPerformed

    private void TargetrollFieldFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_TargetrollFieldFocusGained
        // Add your handling code here:
        
        if ( getRollMode().equals(MANUAL_ROLL) == false ) {
            setRollMode(MANUAL_ROLL);
        }
        
        TargetrollField.selectAll();
    }//GEN-LAST:event_TargetrollFieldFocusGained

    private void TargetrollCheckboxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TargetrollCheckboxActionPerformed
        // Add your handling code here:
        if ( TargetrollCheckbox.isSelected() ) {
            setRollMode(AUTO_ROLL);
            setDice(null);
        }
        else {
            setRollMode(MANUAL_ROLL);
        }
    }//GEN-LAST:event_TargetrollCheckboxActionPerformed
                            /** Getter for property battleEvent.
     * @return Value of property battleEvent.
     */
    public BattleEvent getBattleEvent() {
        return battleEvent;
    }
    
    /** Setter for property battleEvent.
     * @param battleEvent New value of property battleEvent.
     */
    public void setBattleEvent(BattleEvent battleEvent) {
        this.battleEvent = battleEvent;
    }
    
    /** Getter for property dice.
     * @return Value of property dice.
     */
    public Dice getDice() {
        return dice;
    }
    
    /** Setter for property dice.
     * @param dice New value of property dice.
     */
    public void setDice(Dice dice) {
        this.dice = dice;
    }
    
    
    public void showPanel(AttackTreePanel atip) {
        
         
        this.atip = atip;
        setupPanel();
    }
    
    public JPanel getPanel() {
        return this;
    }
    
    public void hidePanel() {
        // When the panel is hidden, make sure you copy the values out
        if ( getBattleEvent() != null) {
            int dindex = battleEvent.getDiceIndex(diceName, targetGroup );
            String rollmode = getRollMode();
            
            if ( rollmode.equals(AUTO_ROLL) ) {
                if ( getDice() == null ) {
                    Dice autoRoll = new Dice(3);
                    battleEvent.setDiceRoll(dindex, autoRoll);
                }
                else {
                    battleEvent.setDiceRoll(dindex, getDice());
                }
                battleEvent.setDiceAutoRoll(dindex, true);
            }
            else if ( rollmode.equals(MANUAL_ROLL) ) {
                String roll = TargetrollField.getText();
                Dice diceRoll = null;
                try {
                    int value = Integer.parseInt(roll);
                    
                    diceRoll = new Dice(value, 0);
                }
                catch(NumberFormatException nfe) {
                    // Don't do anything
                }
                battleEvent.setDiceRoll(dindex, diceRoll);
                battleEvent.setDiceAutoRoll(dindex, false );
            }
        }
        
        
        ActivationInfo ai = battleEvent.getActivationInfo();
        Integer modifier = ai.getIntegerValue( "ActivationInfo.THROWBREAKFALLMODIFIER" );
        if ( modifier == null ) modifier = new Integer(0);
        TargetskillModifier.setValue(modifier);
    }
    
    
    
    /** Getter for property target.
     * @return Value of property target.
     */
    public final Target getTarget() {
        ActivationInfo ai = battleEvent.getActivationInfo();
        Target t = (Target)ai.getValue("ActivationInfo.THROWNOBJECT");
        return t;
    }

    
    public String getAutoBypassOption() {
        return "SHOW_THROW_EFFECT_PANEL";
    }
    
    public Target getAutoBypassTarget() {
        return getTarget();
    }
    
    /** Getter for property dc.
     * @return Value of property dc.
     */
    protected double getDC() {
        return dc;
    }
    
    /** Setter for property dc.
     * @param dc New value of property dc.
     */
    protected  void setDC(double dc) {
        this.dc = dc;

        setupDescription();
    }
    
    protected void setupDescription() {
        
    }
    
    /** Getter for property rollMode.
     * @return Value of property rollMode.
     */
    public String getRollMode() {
        return rollMode;
    }
    
    
    /** Setter for property rollMode.
     * @param rollMode New value of property rollMode.
     */
    public void setRollMode(String rollMode) {
        String oldMode = this.rollMode;
        this.rollMode = rollMode;
        if ( rollMode.equals(MANUAL_ROLL) ) {
            TargetrollCheckbox.setSelected(false);
            
            if ( getDice() != null && getDice().isRealized() ) {
                TargetrollField.setText( getDice().getStun().toString() );
            }
            else {
                TargetrollField.setText( "" );
            }
            
            TargetrollField.requestFocus();
        }
        else if ( rollMode.equals(AUTO_ROLL) ) {
            TargetrollCheckbox.setSelected(true);
            
            TargetrollField.setText("AUTO");
        }
        
        
    }
    /** Getter for property diceName.
     * @return Value of property diceName.
     */
    public String getDiceName() {
        return this.diceName;
    }
    
    /** Setter for property diceName.
     * @param diceName New value of property diceName.
     */
    public void setDiceName(String diceName) {
        this.diceName = diceName;
    }
    
    protected void fireChangeEvent() {
        if ( listenerList != null ) {
            ChangeEvent e = new ChangeEvent(this);
            // Guaranteed to return a non-null array
            Object[] listeners = listenerList.getListenerList();
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length-2; i>=0; i-=2) {
                if (listeners[i]==ChangeListener.class) {
                    // System.out.println( "Firing chance event to: " + listeners[i+1].toString());
                    ((ChangeListener)listeners[i+1]).stateChanged(e);
                }
            }
        }
    }
    
    public boolean PADValueChanging(PADValueEvent evt) {
//        if ( battleEvent != null ) {
//            if ( evt.getSource() == TargetskillModifier ) {
//                Ability ability = battleEvent.getAbility();
//                Integer value = evt.getValue();
//                
//                ActivationInfo ai = battleEvent.getActivationInfo();
//                ai.add("ActivationInfo.THROWBREAKFALLMODIFIER", value, true);
//                updateSkillRoll();
//            }
//        }
        return true;
    }
    
    public void PADValueChanged(PADValueEvent evt) {
        ActivationInfo ai = battleEvent.getActivationInfo();
        ai.add( evt.getKey(), evt.getValue(),true );
        fireChangeEvent();
        updateSkillRoll();
        
    }
    
    
    /** Setter for property targetGroup.
     * @param targetGroup New value of property targetGroup.
     *
     */
    public void setTargetGroup(String targetGroup) {
        this.targetGroup = targetGroup;
        updateSkillRoll();
    }
    
    public String getTargetGroup() {
        return targetGroup;
    }
    
    /*
     
     
     *  Adds a <code>Battle</code> listener.
     *
     *  @param l  the <code>ChangeListener</code> to add
     */
    public void addChangeListener(ChangeListener l) {
        listenerList.add(ChangeListener.class,l);
    }
    
    /**
     * Removes a <code>Battle</code> listener.
     *
     * @param l  the <code>BattleListener</code> to remove
     * //==
     * public void removeChangeListener(ChangeListener l) {
     * listenerList.remove(ChangeListener.class,l);
     * }
     *
     */
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel TargetneededLabel;
    private javax.swing.JCheckBox TargetrollCheckbox;
    private javax.swing.JTextField TargetrollField;
    private champions.PADIntegerEditor TargetskillModifier;
    private javax.swing.JPanel breakfallGroup;
    private javax.swing.JPanel fillerGroup;
    private javax.swing.JLabel jLabel1;
    // End of variables declaration//GEN-END:variables
    
    /** Holds value of property effect. */
    private String effect;
    
    /** Holds value of property dc. */
    private double dc;
    
    private void updateSkillRoll() {
        ActivationInfo ai = battleEvent.getActivationInfo();
        Integer targetmodifier = ai.getIntegerValue( "ActivationInfo.THROWBREAKFALLMODIFIER" );
        Target t = (Target)ai.getValue( "ActivationInfo.THROWNOBJECT" );
        int targetbaseroll = getBreakfallRoll(t);
        
        if ( targetmodifier == null ) targetmodifier = new Integer(0);
        TargetskillModifier.setValue(targetmodifier);
        
        TargetneededLabel.setText( Integer.toString(targetmodifier.intValue() + targetbaseroll - ChampionsUtilities.roundValue(dc/2, true) ) );
    }
    
   
    
     /** Return breakfall roll of target, -1 if target doesn't have breakfall
     *
     */
    protected int getBreakfallRoll(Target target) {
        
        Ability Breakfall = PADRoster.getSharedAbilityInstance("Breakfall");
        
        ActivationInfo ai = battleEvent.getActivationInfo();
        //Target source = Battle.currentBattle.getActiveTarget();
        
        AbilityIterator aiter = target.getSkills();
        
        
        while (aiter.hasNext() ) { // Check to see if there is another item
            // Rip next ability from the iterator.
            // This a is guaranteed to have a power which is actually a skill
            // since we used the getSkills.  If we use getAbilities() we will
            // actually get both skills and powers.
            Ability a = aiter.nextAbility();
            if ( a.isEnabled(target,false) && a.equals(Breakfall)) {
                int targetbaseroll = a.getSkillRoll(target);
                boolean crammed= (Boolean)a.getValue("Power.CRAMMED");
                if (crammed ) {
                    return 8;
                }
                else {
                    return targetbaseroll;
                }
            }
            
        }
        return -1;
    }
    
}
