/*
 * AttackTreeInlinePanel.java
 *
 * Created on October 30, 2001, 1:29 PM
 */

package champions.attackTree;

import champions.InlineView;
import champions.Target;
import champions.exception.BattleEventException;
import champions.interfaces.InlinePanel;
import java.awt.BorderLayout;
import java.awt.Component;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.tree.TreePath;




/**
 * 
 * @author  twalker
 */
public class AttackTreeInlinePanel extends JPanel{// implements InlinePanel, TreeWillSelectListener {
   
////    /** Stores the AttackTreeModel. */
////    protected AttackTreeModel model;
////    
////    protected AttackTreeInputPanel currentPanel;
////    
////    static protected AttackTreeInlinePanel atip;
////    
////    
////    /** Creates new form AttackTreeInlinePanel */
////    public AttackTreeInlinePanel() {
////        initComponents();
////        
////        treePanel.getSelectionModel().addTreeWillSelectListener(this);
////    }
////  
////    /**
////     * Gets the model this node belongs to.
////     */
////    public AttackTreeModel getModel() {
////        return model;
////    }
////    
////    /**
////     * Sets teh model this node belongs to.
////     */
////    public void setModel(AttackTreeModel model) {
////        this.model = model;
////        
////        if ( model.isInlineViewVisible() ) {
////            attachModelToTree();
////        }
////        
////    }
////    
////    public void attachModelToTree() {
////        if ( model != null ) {
////            treePanel.setModel(model);
////        }
////    }
////    
////    /**
////     * Indicates that GUI event occurred which should advance the panel.
////     */
////    public void advanceNode() {
////        showInputPanel(null,null);
////        if ( model != null ) model.advanceNode(null);
////    } 
////    
////    public void showInputPanel(AttackTreeNode activeNode, AttackTreeInputPanel panel) {
////        if ( panel != this.currentPanel || activeNode != this.activeNode ) {
////            if ( this.currentPanel != null ) {
////                inputPanelGroup.remove(this.currentPanel.getPanel());
////                this.currentPanel.hidePanel();
////            }
////            
////            this.currentPanel = panel;
////            this.activeNode = activeNode;
////            
////            setupBypassButton();
////            
////            if ( this.currentPanel != null ) {
////                
////                
////                inputPanelGroup.add(this.currentPanel.getPanel(), BorderLayout.CENTER);
////                this.currentPanel.showPanel(this);
////                
////                // Make sure the InlineView is visible
////                if ( model.isInlineViewVisible() == false ) {
////                    model.displayInlineView();
////                }
////            }
////            
////            inputPanelGroup.revalidate();
////            inputPanelGroup.repaint();
////        }
////    }
////    
////    public void setupBypassButton() {
////        autoBypassButton.reset();
////        
////        if ( activeNode == null ) {
////            autoBypassButton.setVisible(false);
////        }
////        else {
////            Target t = activeNode.getAutoBypassTarget();
////            String o = activeNode.getAutoBypassOption();
////            
////            if ( t != null && o != null ) {
////                autoBypassButton.setTarget(t);
////                autoBypassButton.setOption(o);
////                autoBypassButton.setVisible(true);
////            }
////            else {
////                autoBypassButton.setVisible(false);
////            }
////        }
////    }
////    
////    public void setInstructions(String instructions) {
////        if ( instructions != null ) {
////            instructionsLabel.setText(instructions);
////        }
////        else {
////            instructionsLabel.setText("");
////        }
////    }
////    
////    /** This method is called from within the constructor to
////     * initialize the form.
////     * WARNING: Do NOT modify this code. The content of this method is
////     * always regenerated by the Form Editor.
////     */
    private void initComponents() {//GEN-BEGIN:initComponents
        splitGroup = new javax.swing.JPanel();
        splitPane = new javax.swing.JSplitPane();
        treePanel = new champions.attackTree.TreePanel();
        rightSplitGroup = new javax.swing.JPanel();
        instructionGroup = new javax.swing.JPanel();
        instructionsLabel = new javax.swing.JLabel();
        autoBypassButton = new champions.AutoBypassButton();
        inputPanelGroup = new javax.swing.JPanel();
        
        setLayout(new java.awt.GridBagLayout());
        java.awt.GridBagConstraints gridBagConstraints1;
        
        setPreferredSize(new java.awt.Dimension(600, 300));
        splitGroup.setLayout(new java.awt.GridBagLayout());
        java.awt.GridBagConstraints gridBagConstraints2;
        
        splitPane.setDividerSize(3);
        splitPane.setResizeWeight(0.33);
        splitPane.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(1, 1, 1, 1)));
        splitPane.setLeftComponent(treePanel);
        
        rightSplitGroup.setLayout(new java.awt.GridBagLayout());
        java.awt.GridBagConstraints gridBagConstraints3;
        
        instructionGroup.setLayout(new java.awt.BorderLayout());
        
        instructionGroup.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(153, 153, 204)));
        instructionGroup.setBackground(new java.awt.Color(255, 255, 255));
        instructionsLabel.setForeground(java.awt.Color.black);
        instructionsLabel.setBackground(new java.awt.Color(255, 255, 255));
        instructionsLabel.setOpaque(true);
        instructionGroup.add(instructionsLabel, java.awt.BorderLayout.CENTER);
        
        autoBypassButton.setBorder(new javax.swing.border.EmptyBorder(new java.awt.Insets(0, 0, 0, 2)));
        instructionGroup.add(autoBypassButton, java.awt.BorderLayout.EAST);
        
        gridBagConstraints3 = new java.awt.GridBagConstraints();
        gridBagConstraints3.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints3.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints3.weightx = 1.0;
        rightSplitGroup.add(instructionGroup, gridBagConstraints3);
        
        inputPanelGroup.setLayout(new java.awt.BorderLayout());
        
        inputPanelGroup.setPreferredSize(new java.awt.Dimension(300, 600));
        gridBagConstraints3 = new java.awt.GridBagConstraints();
        gridBagConstraints3.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints3.gridheight = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints3.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints3.weightx = 1.0;
        gridBagConstraints3.weighty = 1.0;
        rightSplitGroup.add(inputPanelGroup, gridBagConstraints3);
        
        splitPane.setRightComponent(rightSplitGroup);
        
        gridBagConstraints2 = new java.awt.GridBagConstraints();
        gridBagConstraints2.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints2.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints2.weightx = 1.0;
        gridBagConstraints2.weighty = 1.0;
        splitGroup.add(splitPane, gridBagConstraints2);
        
        gridBagConstraints1 = new java.awt.GridBagConstraints();
        gridBagConstraints1.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints1.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints1.weightx = 1.0;
        gridBagConstraints1.weighty = 1.0;
        add(splitGroup, gridBagConstraints1);
        
    }//GEN-END:initComponents
            
    private void advanceButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_advanceButtonActionPerformed
        // Add your handling code here:
  //      advanceNode();
    }//GEN-LAST:event_advanceButtonActionPerformed
    
//    public Component getInlineComponent() {
//        return splitGroup;
//    }
//    
//    public void deactivateInline(InlineView inlineView, int value) {
//        //System.out.println("AttackTreeInlinePanel deactivated."); 
//        // Unattached the model...
//        if ( treePanel != null ) treePanel.setModel(null); 
//    }
//    
//    public void activateInline(InlineView inlineView) {
//    }
//    
//    public Object[] getButtons() {
//        return new Object[] {
//            "Okay", new Integer(JOptionPane.OK_OPTION),
//            "Cancel", new Integer( JOptionPane.CANCEL_OPTION )
//        };
//    }
//    
//    public String getTitle() {
//        return "Attack Panel";
//    }
//    
//    public String getInstructions() {
//        return "";
//    }
//    
//    public boolean buttonPressed(InlineView inlineView, int value) {
//        boolean result = true;
//        if ( value == JOptionPane.OK_OPTION ) {
//            advanceNode();
//            result = model.isFinished();
//        }
//        else if ( value == JOptionPane.CANCEL_OPTION ) {
//            model.setError( new BattleEventException("BattleEvent Cancelled", false) );
//        }
//        return result;
//    }
//    
//    /**
//     * Initializes a AttackTreeInlinePanel and returns the panel.
//     */
//    static public AttackTreeInlinePanel getAttackTreeInlinePanel(AttackTreeModel atm) {
//        if ( atip == null ) atip = new AttackTreeInlinePanel();
//        
//        //atip.inititializePanel(be);
//        //atip.setInlineView(iv);
//        atip.setModel(atm);
//        
//        return atip;
//    }
//    
//   /* public void inititializePanel(BattleEvent be) {
//        AttackProcessNode rn = new AttackProcessNode("Root");
//        AttackTreeModel atm = new AttackTreeModel(rn);
//        atm.setBattleEvent(be);
//        atm.setInlinePanel(this);
//        atm.setTree(treePanel.getTree());
//        
//        
//        setModel(atm);
//        
//        atm.activateNode(null, null);
//    } */
//    
//    public boolean valueWillChange(TreeSelectionEvent tse) {
//        TreePath tp = tse.getNewLeadSelectionPath();
//        if ( tp  == null ) {
//            return false;
//        }
//        else if ( (tp.getLastPathComponent() instanceof AttackTreeNode) == false ) {
//            return false;
//        }
//        else {
//            
//            AttackTreeNode atn = (AttackTreeNode) tp.getLastPathComponent();
//            AttackTreeNode activeNode = getModel().getActiveNode();
//            AttackTreeModel atm = getModel();
//            
//            if ( atm != null && atn != null && atn != activeNode ) {
//                if ( atm.getRealPreorderPosition(activeNode) > atm.getRealPreorderPosition(atn) ) {
//                    // The activeNode is after this node, so go ahead and active the new node directly.
//                    atm.activateNode(atn, atn);
//                }
//                else {
//                    // The activeNode is currently before this node, so run advanceNode with atn as the manual override
//                    atm.advanceNode(atn);
//                }
//            }
//            return false;
//        }
//    }
//
//    public boolean requiresScroll(InlineView inlineView) {
//        return false;
//    }    
//    
//    /** Getter for property activeNode.
//     * @return Value of property activeNode.
//     */
//    public AttackTreeNode getActiveNode() {
//        return activeNode;
//    }
//    
//    /** Setter for property activeNode.
//     * @param activeNode New value of property activeNode.
//     */
//    public void setActiveNode(AttackTreeNode activeNode) {
//        this.activeNode = activeNode;
//    }
//    
//    /** Getter for property inlineView.
//     * @return Value of property inlineView.
//     */
//    public InlineView getInlineView() {
//        return inlineView;
//    }
//    
//    /** Setter for property inlineView.
//     * @param inlineView New value of property inlineView.
//     */
//    public void setInlineView(InlineView inlineView) {
//        this.inlineView = inlineView;
//    }
//    
//    public champions.attackTree.TreePanel getTreePanel() {
//        return treePanel;
//    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel splitGroup;
    private javax.swing.JSplitPane splitPane;
    private champions.attackTree.TreePanel treePanel;
    private javax.swing.JPanel rightSplitGroup;
    private javax.swing.JPanel instructionGroup;
    private javax.swing.JLabel instructionsLabel;
    private champions.AutoBypassButton autoBypassButton;
    private javax.swing.JPanel inputPanelGroup;
    // End of variables declaration//GEN-END:variables

    /** Holds value of property activeNode. */
    private AttackTreeNode activeNode;    
    
    /** Holds value of property inlineView. */
    private InlineView inlineView;
    
}
