/*
 * AttackParametersPanel.java
 *
 * Created on October 31, 2001, 11:53 PM
 */

package champions.attackTree;

import champions.Ability;
import champions.CombinedAbilityBattleEvent;
import champions.Target;
import java.awt.Component;
import javax.swing.*;
import javax.swing.event.*;

/**
 *
 * @author  twalker
 */
public class CombinedSetupPanel extends JPanel implements AttackTreeInputPanel, ListSelectionListener {
    /** Stores a cached AttackParametersPanel which can be reused. */
    static protected CombinedSetupPanel ad = null;
    
    /** Stores a cached AttackParametersPanel which can be reused. */
    protected CombinedAbilityBattleEvent battleEvent = null;
    
    /** Stores the EventListenerList */
    protected EventListenerList listenerList;
    
    /** Creates new form AttackParametersPanel */
    public CombinedSetupPanel() {
        initComponents();
        
        combinedList.setCellRenderer( new CombinedListCellRenderer("CombinedAbility.Icon", "CombinedAbility.Icon"));
        combinedList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        
        combinedList.addListSelectionListener(this);
        
        setupActions();
    }
    
    public void setupActions() {

    }
    
    static public CombinedSetupPanel getCombinedSetupPanel(CombinedAbilityBattleEvent be) {
        if ( ad == null ) ad = new CombinedSetupPanel();
        
        ad.setBattleEvent(be);
        
        // Clear any old listeners by creating a new listener list.
        ad.listenerList = new EventListenerList();
        
        return ad;
    }
    
    /** Getter for property battleEvent.
     * @return Value of property battleEvent.
     */
    public CombinedAbilityBattleEvent getBattleEvent() {
        return battleEvent;
    }
    /** Setter for property battleEvent.
     * @param battleEvent New value of property battleEvent.
     */
    public void setBattleEvent(CombinedAbilityBattleEvent battleEvent) {
        this.battleEvent = battleEvent;
        
    }
    
    protected void fireChangeEvent() {
        if ( listenerList != null ) {
            ChangeEvent e = new ChangeEvent(this);
            // Guaranteed to return a non-null array
            Object[] listeners = listenerList.getListenerList();
            // Process the listeners last to first, notifying
            // those that are interested in this event
            for (int i = listeners.length-2; i>=0; i-=2) {
                if (listeners[i]==ChangeListener.class) {
                    // System.out.println( "Firing chance event to: " + listeners[i+1].toString());
                    ((ChangeListener)listeners[i+1]).stateChanged(e);
                }
            }
        }
    }
    
    private void updatePanel() {
        updateControls();
        combinedList.repaint();
    }
    
    /**
     *  Adds a <code>Battle</code> listener.
     *
     *  @param l  the <code>ChangeListener</code> to add
     */
    public void addChangeListener(ChangeListener l) {
        listenerList.add(ChangeListener.class,l);
    }
    
    /**
     * Removes a <code>Battle</code> listener.
     *
     * @param l  the <code>BattleListener</code> to remove
     */
    public void removeChangeListener(ChangeListener l) {
        listenerList.remove(ChangeListener.class,l);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        continuousGroup = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        combinedList = new javax.swing.JList();

        setLayout(new java.awt.BorderLayout());

        continuousGroup.setBorder(javax.swing.BorderFactory.createEmptyBorder(5, 5, 0, 0));

        jLabel1.setText("The following abilities are combined and will be triggered in the shown order:");

        jScrollPane1.setViewportView(combinedList);

        javax.swing.GroupLayout continuousGroupLayout = new javax.swing.GroupLayout(continuousGroup);
        continuousGroup.setLayout(continuousGroupLayout);
        continuousGroupLayout.setHorizontalGroup(
            continuousGroupLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(continuousGroupLayout.createSequentialGroup()
                .addGroup(continuousGroupLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(continuousGroupLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 482, Short.MAX_VALUE))
                    .addComponent(jLabel1))
                .addContainerGap())
        );
        continuousGroupLayout.setVerticalGroup(
            continuousGroupLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(continuousGroupLayout.createSequentialGroup()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 427, Short.MAX_VALUE)
                .addContainerGap())
        );

        add(continuousGroup, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    
    public void showPanel(AttackTreePanel atip) {
        setupPanel();
    }
    
    public JPanel getPanel() {
        return this;
    }
    
    public void hidePanel() {
        
    }
    
    public void setupPanel() {
        combinedList.setModel( new CombinedListModel( battleEvent) );
        updateControls();
    }
    
    public void valueChanged(ListSelectionEvent e) {
        updateControls();
    }
    
    private void updateControls() {

        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList combinedList;
    private javax.swing.JPanel continuousGroup;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
    
    public class CombinedListCellRenderer extends JLabel implements ListCellRenderer {
        
        private Icon checkedIcon = null;
        private Icon uncheckedIcon = null;
        
        public CombinedListCellRenderer(String checkedIconProperty, String uncheckedIconProperty) {
            checkedIcon = UIManager.getIcon(checkedIconProperty);
            uncheckedIcon = UIManager.getIcon(uncheckedIconProperty);
        }
        // This is the only method defined by ListCellRenderer.
        // We just reconfigure the JLabel each time we're called.
        
        public Component getListCellRendererComponent(
        JList list,
        Object value,            // value to display
        int index,               // cell index
        boolean isSelected,      // is the cell selected
        boolean cellHasFocus)    // the list and the cell have the focus
        {
            String s = value.toString();
            setText(s);
            
            if ( battleEvent != null ) {
                if ( battleEvent.isCombinedAbilityEnabled(index) ) {
                    setIcon(checkedIcon);
                }
                else {
                    setIcon(uncheckedIcon);
                }
            }
            
            if ( isSelected ) {
                setBackground(list.getSelectionBackground());
                setForeground(list.getSelectionForeground());
            }
            else {
                setBackground(list.getBackground());
                setForeground(list.getForeground());
            }
            
            setEnabled(list.isEnabled());
            setFont(list.getFont());
            setOpaque(true);
            return this;
        }
    }
    
    public static class CombinedListModel extends AbstractListModel {
        
        private CombinedAbilityBattleEvent battleEvent;
        
        public CombinedListModel(CombinedAbilityBattleEvent battleEvent) {
            this.battleEvent = battleEvent;
        }
        
        public Object getElementAt(int index) {
            if ( battleEvent != null ) {
                Target source = battleEvent.getSource();
                
                Ability ability = battleEvent.getCombinedAbility(index);
                
                if ( ability.isActivated(source) ) {
                    return ability.getName() + " (Already activated, skipping)";
                }
                else {
                    Ability maneuver = null;

                    if ( maneuver != null ) {
                        return ability.getName() + " with maneuver " + maneuver.getName();
                    }
                    else {
                        return ability.getName();
                    }
                }
            }
            return "ERROR";
        }
        
        public int getSize() {
            return (battleEvent == null) ? 0 : battleEvent.getCombinedAbilityCount();
        }
        
    }
}
