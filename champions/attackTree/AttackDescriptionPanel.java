/*
 * AttackDescriptionPanel.java
 *
 * Created on December 16, 2001, 11:33 AM
 */

package champions.attackTree;

import champions.Ability;
import champions.ActivationInfo;
import champions.BattleEvent;
import champions.Chronometer;
import champions.Target;
import javax.swing.JPanel;


/**
 *
 * @author  twalker
 */
public class AttackDescriptionPanel extends JPanel implements AttackTreeInputPanel {

    /** Holds value of property battleEvent. */
    private BattleEvent battleEvent;
    
    static private AttackDescriptionPanel defaultPanel;
    
    /** Holds value of property ability. */
    private Ability ability;
    
    /** Holds value of property maneuver. */
    private Ability maneuver;
    
    /** Holds value of property source. */
    private Target source;
    
    /** Creates new form AttackDescriptionPanel */
    public AttackDescriptionPanel() {
        initComponents();
    }
    
    static public AttackDescriptionPanel getDefaultPanel(BattleEvent be) {
        if ( defaultPanel == null ) defaultPanel = new AttackDescriptionPanel();
        
        defaultPanel.setBattleEvent(be);
        
        return defaultPanel;
    }
    
    private void updatePanel() {
        StringBuffer sb = new StringBuffer();
        
        ActivationInfo ai = battleEvent.getActivationInfo();
        
        boolean delayed = (battleEvent.getType() == BattleEvent.DELAYED_ACTIVATE);
        
        String type = "power";
        if ( ability.isSkill() ) {
            type = "skill";
        }
        if ( ability.isDisadvantage() ) {
            type = "Disadvantage";
        }        
        if ( battleEvent.getType() == BattleEvent.CHARGE_END ) {
            sb.append ("END is being charged for ");
            sb.append( source.getName() );
            sb.append( "'s continuous ");
            sb.append(type);
            sb.append(" ");
            sb.append( ability.getName() );
            sb.append(".");
        }  
        else if ( delayed ) {
            sb.append( source.getName() );
            sb.append( " is finishing the delayed activation of the " );
            sb.append(type);
            sb.append(" ");
            sb.append( ability.getName() );
            if ( maneuver != null ) {
                sb.append( " with the manuever " );
                sb.append( maneuver.getName() );
                
            }
            sb.append(".");
            
            Chronometer time = ai.getStartTime();
            sb.append("\n\nThis ");
            sb.append(type);
            sb.append(" was originally started at ");
            sb.append(time.toString());
            sb.append(".\n");
        }
        else if ( ai.isContinuing() ) {
            sb.append( source.getName() );
            sb.append( "'s continuous ");
            sb.append(type);
            sb.append(" ");
            sb.append( ability.getName() );
            sb.append( " is continuing. ");
            if ( maneuver != null ) {
                sb.append( source.getName() );
                sb.append( " is using this ");
                sb.append(type);
                sb.append(" with the maneuver " );
                sb.append( maneuver.getName() );
                sb.append( ".\n");
            }
            
            if ( battleEvent.isENDPaid() ) { 
                sb.append("\nEND has already been paid for this ability and will not be charged.");
            }
            
            Chronometer time = ai.getStartTime();
            sb.append("\n\nThis ");
            sb.append(type);
            sb.append(" was originally started at ");
            sb.append(time.toString());
            sb.append(".\n");
        }
        else {
            sb.append( source.getName() );
            sb.append( " is activating the " );
            sb.append(type);
            sb.append(" ");
            sb.append( ability.getName() );
            if ( maneuver != null ) {
                sb.append( " with the manuever " );
                sb.append( maneuver.getName() );
                
            }
            sb.append( ".\n");
        }
        
        attackDescription.setText(sb.toString());
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        attackDescription = new javax.swing.JTextArea();
        abilityLabel = new javax.swing.JLabel();
        abilityDescription = new javax.swing.JTextArea();
        maneuverLabel = new javax.swing.JLabel();
        maneuverDescription = new javax.swing.JTextArea();
        fillerPanel = new javax.swing.JPanel();

        setLayout(new java.awt.GridBagLayout());

        attackDescription.setBackground(new java.awt.Color(204, 204, 204));
        attackDescription.setEditable(false);
        attackDescription.setLineWrap(true);
        attackDescription.setWrapStyleWord(true);
        attackDescription.setOpaque(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        add(attackDescription, gridBagConstraints);

        abilityLabel.setText("jLabel1");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        add(abilityLabel, gridBagConstraints);

        abilityDescription.setBackground(new java.awt.Color(204, 204, 204));
        abilityDescription.setEditable(false);
        abilityDescription.setLineWrap(true);
        abilityDescription.setWrapStyleWord(true);
        abilityDescription.setOpaque(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        add(abilityDescription, gridBagConstraints);

        maneuverLabel.setText("jLabel2");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        add(maneuverLabel, gridBagConstraints);

        maneuverDescription.setBackground(new java.awt.Color(204, 204, 204));
        maneuverDescription.setEditable(false);
        maneuverDescription.setLineWrap(true);
        maneuverDescription.setWrapStyleWord(true);
        maneuverDescription.setOpaque(false);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        add(maneuverDescription, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(fillerPanel, gridBagConstraints);

    }
    // </editor-fold>//GEN-END:initComponents

    

    public void showPanel(AttackTreePanel atip) {
        setAbility(battleEvent.getAbility());
        setManeuver(battleEvent.getManeuver());
        setSource(battleEvent.getSource());
        updatePanel();
    }    
    
    public JPanel getPanel() {
        return this;
    }
    
    public void hidePanel() {
    }
    
    /** Getter for property battleEvent.
     * @return Value of property battleEvent.
     */
    public BattleEvent getBattleEvent() {
        return battleEvent;
    }
    
    /** Setter for property battleEvent.
     * @param battleEvent New value of property battleEvent.
     */
    public void setBattleEvent(BattleEvent battleEvent) {
        this.battleEvent = battleEvent;
    }
    
    /** Getter for property ability.
     * @return Value of property ability.
     */
    public Ability getAbility() {
        return ability;
    }
    
    /** Setter for property ability.
     * @param ability New value of property ability.
     */
    public void setAbility(Ability ability) {
        this.ability = ability;
        abilityLabel.setText( "Ability " + ability.getName() +":");
        abilityDescription.setText( ability.getDescription() );
    }
    
    /** Getter for property maneuver.
     * @return Value of property maneuver.
     */
    public Ability getManeuver() {
        return maneuver;
    }
    
    /** Setter for property maneuver.
     * @param maneuver New value of property maneuver.
     */
    public void setManeuver(Ability maneuver) {
        this.maneuver = maneuver;
        if ( maneuver != null ) {
        maneuverLabel.setText( "Maneuver " + maneuver.getName() + ":");
        maneuverDescription.setText( maneuver.getDescription() );
        maneuverLabel.setVisible(true);
        maneuverDescription.setVisible(true);
        }
        else {
            maneuverLabel.setVisible(false);
        maneuverDescription.setVisible(false);
        }
    }
    
    /** Getter for property source.
     * @return Value of property source.
     */
    public Target getSource() {
        return source;
    }
    
    /** Setter for property source.
     * @param source New value of property source.
     */
    public void setSource(Target source) {
        this.source = source;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextArea abilityDescription;
    private javax.swing.JLabel abilityLabel;
    private javax.swing.JTextArea attackDescription;
    private javax.swing.JPanel fillerPanel;
    private javax.swing.JTextArea maneuverDescription;
    private javax.swing.JLabel maneuverLabel;
    // End of variables declaration//GEN-END:variables

}
