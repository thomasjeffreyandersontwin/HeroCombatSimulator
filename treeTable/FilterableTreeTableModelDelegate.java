/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package treeTable;

import tjava.Filter;

/** This interface should be supported by TreeTableModels which wish to make use of the ProxyFilterableTreeTableModel.
 *
 * @param <N> Type of node used by the model.
 * @author twalker
 */
public interface FilterableTreeTableModelDelegate<N> extends TreeTableModel<N> {

    public static final String FILTERABLE_DELEGATE_PROPERTY = "FILTERABLE_DELEGATE_PROPERTY";

    /** Returns whether this TreeTableModel is currently filterable.
     *
     * If a TreeTableModel does not currently want to be filtered,
     * it can return false from this method.
     * <P>
     * A FILTERABLE_DELEGATE_PROPERTY change event should be posted
     * when this value changes.
     *
     * @return true if the model is filterable, false otherwise.
     */
    public boolean isFilterableDelegate();

    /** Returns a Filter based opon the specified filterObject.
     *
     * This Filter is the filter that will be used via the isNodeIncluded
     * method.  Basically, this method should translate from the
     * generic filterObject produced by the tree into an actual
     * Filter.  This gives the delegate a chance to create a Filter
     * based on the filterObject so that it doesn't have to produce that
     * filter every time isNodeFiltered is called.
     * <p>
     * If the returned filter is null, it is assumed that the filterObject
     * does not map to a filter and no filter should be applied.  Models
     * that want to filter on filterObject but don't want to use a Filter,
     * should still return a dummy Filter.
     *
     * @param filterObject The object generated by the TreeTable representing the current filter.
     * @return A Filter.  If null, no filter will be applied (and any current filter will be
     * removed).
     */
    public Filter<N> setupFilter(Object filterObject);

    /** Returns true if the node should be filtered from the model.
     *
     * This allows the delegate to customize the handling of filtering, possibly
     * ignoring the filter or filterObject completely.  This method does
     * not need to consider the filtering of its children.  If this method
     * returns false, it is still possible that it will be included if
     * two conditions occur: childrenShouldBeFiltered for this node returns true
     * and one or more of this nodes children remains after filtering.
     * <p>
     * Note: This method should return true if the node should be filtered (ie not
     * included) in the model.  This is the opposite of what Filter.includeElement
     * typically returned.  I did this just so the naming of the method included
     * the word filter and more obviously belonged to this interface.
     *
     * @param filter Filter, as returned by setupFilter, gauranteed non-null.
     * @param node A node from the TreeTableModel which is being considered for filtering.
     * @return true if the node should be included in the model, given the filter.
     */
    public boolean isNodeFiltered(N node, Filter<N> filter);

    /** Returns if the nodes children should be filtered.
     *
     * If true, the parentNodes children will be filtered prior calling isNodeFiltered.
     * If false, all children will be included in the model.  The children's children
     * will still be filtered recursively.  Returning true from this method effectively
     * forces the all calls to isNodeFiltered for all children of parentNode to return
     * true.
     *
     * @param parentNode A node from the TreeTableModel whose children are being considered for filtering.
     * @param filter Filter, as returned by setupFilter, gauranteed non-null.
     * @return true if the children should evaluated for filtered, false if they should all be
     * included without filtering.
     */
    public boolean childrenShouldBeFiltered(N parentNode, Filter<N> filter);

    /** Tells the delegate that the children of parentNode is about to be filtered.
     *
     * This is called prior to the children of parentNode being examined for filtering.
     * This will only be called if isNodeFiltered is false for the parent node or
     * childrenShouldBeFiltered is true for the parent node.  In other words, this will only be
     * called if there is a reason to filter the children.
     *
     * @param parentNode Node whose children will be filtered.
     * @param filter Filter, as returned by setupFilter, gauranteed non-null.
     */
    public void willFilterChildren(N parentNode, Filter<N> filter);

    /** Returns whether this node wishes to be pruned if filtering removed all of it's children.
     *
     * This will only be called if parentNode has no children after filtering.
     *
     * @param parentNode Node with no children after filtering, eligible for pruning.
     * @param filter Filter, as returned by setupFilter, gauranteed non-null.
     * @return True if this node should be pruned.
     */
    public boolean isNodePruned(N parentNode, Filter<N> filter);


}
